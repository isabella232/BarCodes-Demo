"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const URI = require("urijs");
const util_1 = require("../shared/util");
const util_2 = require("../shared/util");
class ServiceClientBase {
    constructor(discovery, adminToken, authorizationHeaderName, tags) {
        this.discovery = discovery;
        this.adminToken = adminToken;
        this.authorizationHeaderName = authorizationHeaderName;
        this.tags = tags;
    }
    getRoute(...segments) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = yield this.discovery.waitForService(this.serviceName, this.tags);
            segments.unshift(this.baseRoute);
            return new URI(`http://${service.address}:${service.port}`)
                .segmentCoded(segments)
                .toString();
        });
    }
    findService() {
        return this.discovery.find(this.serviceName, this.tags);
    }
    executeRequest(request, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (token === undefined) {
                    token = this.adminToken;
                }
                if (token) {
                    request = request.set({
                        [this.authorizationHeaderName]: token
                    });
                }
                const retry = util_2.retryRequest(3, 2000, (response) => {
                    return response.status === 404 ||
                        response.status === 502 ||
                        response.status === 503 ||
                        response.status === 504;
                });
                const response = yield request.use(retry);
                return response.body;
            }
            catch (e) {
                throw util_1.convertHttpError(e);
            }
        });
    }
}
exports.ServiceClientBase = ServiceClientBase;
//# sourceMappingURL=ServiceClientBase.js.map