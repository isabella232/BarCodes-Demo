"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const virtPath_1 = require("./virtPath");
const errors = require("../errors");
const URI = require("urijs");
function Promisify(callback, ...args) {
    return new Promise((resolve, reject) => {
        callback(...args, (err, result) => {
            if (err)
                reject(err);
            else {
                resolve(result);
            }
        });
    });
}
exports.Promisify = Promisify;
class TimeoutError extends Error {
    constructor(ms) {
        super(`Operation failed to complete within ${ms}ms`);
        this.ms = ms;
    }
}
exports.TimeoutError = TimeoutError;
function timeout(promise, ms) {
    const timeoutPromise = new Promise((resolve, reject) => {
        const id = setTimeout(() => {
            clearTimeout(id);
            reject(new TimeoutError(ms));
        }, ms);
    });
    return Promise.race([promise, timeoutPromise]);
}
exports.timeout = timeout;
function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.delay = delay;
function validateRealmPath(path, userId) {
    if (!path) {
        throw new errors.realm.MissingParameters('path');
    }
    let decodedPath = URI.decode(path);
    if (decodedPath.includes('~')) {
        if (userId) {
            decodedPath = decodedPath.replace('~', userId);
        }
        else {
            throw new errors.realm.InvalidParameters({
                name: 'path',
                reason: `path cannot contain a ~. Please use a full absolute path when trying to find the realmFile.`
            });
        }
    }
    if (!decodedPath.startsWith('/')) {
        decodedPath = '/' + decodedPath;
    }
    if (!virtPath_1.mapVirtToRealmPath("/", decodedPath)) {
        throw new errors.realm.InvalidParameters({
            name: 'path',
            reason: `path is invalid. It should start with a slash, consist of Latin letters (A-Z, a-z), digits (0-9), dot (.), dash (-), and underscore (_). All components should be non-empty and not start with a dot. The path should not end with .realm, .realm.lock or .realm.management.`
        });
    }
    return decodedPath;
}
exports.validateRealmPath = validateRealmPath;
function getUserIdFromRealmPath(path) {
    if (path === '' || path[0] !== '/') {
        return undefined;
    }
    const segments = new URI(path).segment();
    const partialIndex = segments.indexOf('__partial');
    if (partialIndex !== -1) {
        return segments[partialIndex + 1];
    }
    else {
        return segments[0];
    }
}
exports.getUserIdFromRealmPath = getUserIdFromRealmPath;
function waitForDownload(realm) {
    return waitForProgress(realm, 'download');
}
exports.waitForDownload = waitForDownload;
function waitForUpload(realm) {
    return waitForProgress(realm, 'upload');
}
exports.waitForUpload = waitForUpload;
function convertHttpError(error) {
    if (error.response && error.response.body) {
        const body = error.response.body;
        if (body.hasOwnProperty('code') && body.hasOwnProperty('status')) {
            if (body.hasOwnProperty('invalid_params')) {
                const params = body.invalid_params;
                delete body.invalid_params;
                body.invalidParams = params;
            }
            return body;
        }
    }
    return error;
}
exports.convertHttpError = convertHttpError;
function waitForProgress(realm, direction) {
    return new Promise((resolve, reject) => {
        realm.syncSession.addProgressNotification(direction, 'forCurrentlyOutstandingWork', (completed, completable) => {
            if (completed === completable) {
                resolve();
            }
        });
    });
}
function waitAsync(getter, verifier, timeout = 5000) {
    return __awaiter(this, void 0, void 0, function* () {
        const msDelay = 50;
        if (!verifier) {
            verifier = (res) => !!res;
        }
        let result;
        for (let i = 0; i < timeout / msDelay; i++) {
            result = yield Promise.resolve(getter());
            if (verifier(result)) {
                return result;
            }
            else {
                yield delay(msDelay);
            }
        }
        throw new TimeoutError(timeout);
    });
}
exports.waitAsync = waitAsync;
function retryRequest(retries = 1, delay = 100, shouldRetry = _ => true) {
    return function (request) {
        request["callback"] = function callback(error, response) {
            if ((error || (!this._isResponseOK(response) && shouldRetry(response))) && retries-- > 0) {
                return setTimeout(() => this._retry(), delay);
            }
            this.__proto__.callback.call(this, error, response);
        };
    };
}
exports.retryRequest = retryRequest;
//# sourceMappingURL=util.js.map